import { Observable } from 'rxjs';
import { SocketIoConfig } from './config/socket-io.config';
export declare class WrappedSocket {
    private config;
    subscribersCounter: Record<string, number>;
    eventObservables$: Record<string, Observable<any>>;
    namespaces: Record<string, WrappedSocket>;
    ioSocket: any;
    emptyConfig: SocketIoConfig;
    constructor(config: SocketIoConfig);
    /**
     * Gets a WrappedSocket for the given namespace.
     *
     * @note if an existing socket exists for the given namespace, it will be reused.
     *
     * @param namespace the namespace to create a new socket based on the current config.
     *        If empty or `/`, then the current instance is returned.
     * @returns a socket that is bound to the given namespace. If namespace is empty or `/`,
     *          then `this` is returned, otherwise another instance is returned, creating
     *          it if it's the first use of such namespace.
     */
    of(namespace: string): WrappedSocket;
    on(eventName: string, callback: Function): this;
    once(eventName: string, callback: Function): this;
    connect(): this;
    disconnect(): this;
    emit(_eventName: string, ..._args: any[]): this;
    send(..._args: any[]): this;
    emitWithAck<T>(_eventName: string, ..._args: any[]): Promise<T>;
    removeListener(_eventName: string, _callback?: Function): this;
    removeAllListeners(_eventName?: string): this;
    fromEvent<T>(eventName: string): Observable<T>;
    fromOneTimeEvent<T>(eventName: string): Promise<T>;
    listeners(eventName: string): Function[];
    listenersAny(): Function[];
    listenersAnyOutgoing(): Function[];
    off(eventName?: string, listener?: Function[]): this;
    offAny(callback?: (event: string, ...args: any[]) => void): this;
    offAnyOutgoing(callback?: (event: string, ...args: any[]) => void): this;
    onAny(callback: (event: string, ...args: any[]) => void): this;
    onAnyOutgoing(callback: (event: string, ...args: any[]) => void): this;
    prependAny(callback: (event: string, ...args: any[]) => void): this;
    prependAnyOutgoing(callback: (event: string | symbol, ...args: any[]) => void): this;
    timeout(value: number): this;
    get volatile(): this;
    get active(): boolean;
    get connected(): boolean;
    get disconnected(): boolean;
    get recovered(): boolean;
    get id(): string;
    compress(value: boolean): this;
}
